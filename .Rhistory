install.packages(c("GPFDA", "lme4"))
library(lme4)
#Load the packages :
library(FrechForest)
help("FrechForest") # To check the informations about the different functions
library(randomForest)
library(rpart)
library(kmlShape)
library(lme4)
library(GPFDA)
library(FDboost)
library(latex2exp)
install.packages("FDboost")
devtools::check_cran()
devtools::submit_cran()
library(devtools)
install_github("boost-R/FDboost")
install.packages("profvis")
#Load the packages :
library(FrechForest)
help("FrechForest") # To check the informations about the different functions
library(randomForest)
library(rpart)
library(kmlShape)
library(lme4)
library(GPFDA)
library(FDboost)
library(latex2exp)
# This function will simulate dataset according to the scheme of simulations in the paper :
DataGenCurves2 <- function(n, disp){
# n is the number of curves
# disp is the variance of the beta parameter
time <- seq(0,1,0.05) # Measurement times for inputs and output
id <- NULL # Id of the different curves
for (i in 1:n){
id <- c(id,rep(i,length(time)))
}
G1 <- 1*(runif(n)<0.5)  # Groupes of trajectories for the first input variable
G2 <- 1*(runif(n)<0.5)  # Groupes of trajectories for the second input variable
# Define the typical temporal behavior functions f.,. for the input variables :
f11 <- function(t){
return(0.5*t+0.1*sin(6*t))
}
f12 <- function(t){
return(0.3-0.7*(t-0.45)^2)
}
f21 <- function(t){
return(2*(t-0.5)^2 - t*0.3)
}
f22 <- function(t){
return(0.2 -0.3*t + 0.1*cos(8*t))
}
# Simulation of the Input Variables :
X1 <- NULL
X2 <- NULL
beta <- rnorm(n,1,disp) # Dilatation terms
for (i in 1:n){
X1 <- c(X1, beta[i]*((G1[i]==1)*f11(time)+(G1[i]==0)*f12(time)))
X2 <- c(X2, beta[i]*((G2[i]==1)*f21(time)+(G2[i]==0)*f22(time)))
}
X1 <- X1+ rnorm(length(X1), 0,0.02) # We add some noise
X2 <- X2+ rnorm(length(X2), 0,0.02) # We add some noise
X <- data.frame(X1,X2) # Data matrix
# Define the timepical temporal behavior functions g.,. for the Output :
g11 <- function(t){
return(t+ 0.3*sin(10*(t+1)))
}
g12<- function(t){
return(t+2*(t-0.7)^2)
}
g21 <- function(t){
return(1.5*exp(-(t-0.5)^2/0.5)- 0.1*(t+1)*cos(10*t))
}
g22 <- function(t){
return(log(13*abs(t+0.2))/(1+t))
}
# Output simulation :
Y <- NULL
for (i in 1:n){
Y <- c(Y, beta[i]*((G1[i]==1 & G2[i]==0)*(g11(time))+ (G1[i]==1 & G2[i]==1)*(g12(time )) + (G1[i]==0 & G2[i]==1)*(g21(time)) + (G1[i]==0 & G2[i]==0)*(g22(time))))
}
Y <- Y+ rnorm(length(Y), 0, 0.05) # We add some noise
# Here we plot the simulated data :
par(mfrow=c(1,3))
w <- which(id==1)
plot(time,X1[w], type="l", ylim=c(min(X1), max(X1)), col="grey",ylab="", xlab="time", main=TeX("$X^{(1)}$"))
for (i in 2:n){
w <- which(id==i)
lines(time,X1[w],col="grey")
}
lines(time,f11(time), col=1, lwd=2, lty=1)
lines(time,f12(time), col=1, lwd=2, lty=2)
legend("topleft", c(TeX("$f_{1,1}$"), TeX("f_{1,2}")), col=c(1,1), lty=c(1,2), lwd=c(2,2))
w <- which(id==1)
plot(time,X2[w], type="l", ylim=c(min(X2), max(X2)), col="grey", ylab="", xlab="time", main=TeX("$X^{(2)}$"))
for (i in 2:n){
w <- which(id==i)
lines(time,X2[w], col="grey")
}
lines(time,f21(time), col=1, lwd=2, lty=1)
lines(time,f22(time), col=1, lwd=2, lty=2)
legend("topleft", c(TeX("$f_{2,1}$"), TeX("f_{2,2}")), col=c(1,1), lty=c(1,2), lwd=c(2,2))
w <- which(id==1)
plot(time,Y[w], type="l", ylim=c(min(Y), max(Y)), col="grey", xlab="time", ylab="", main = TeX("$Y$"))
for (i in 1:n){
w <- which(id==i)
lines(time,Y[w], col="grey")
}
lines(time, g11(time), col=1, lwd=3, lty=1)
lines(time, g12(time), col=2, lwd=3, lty=2)
lines(time, g21(time), col=3, lwd=7, lty=3)
lines(time, g22(time), col=4, lwd=3, lty=4)
legend("topleft", c(TeX("$g_{1,1}$"), TeX("$g_{1,2}$"), TeX("$g_{2,1}$"), TeX("$g_{2,2}$")), col=c(1,2,3,4), lty=c(1,2,3,4), lwd=c(3,3,7,3))
par(mfrow=c(1,1))
return(list(X=X,Y=Y,time=rep(time,n), id=id))
}
# This function will simulate dataset according to the scheme of simulations in the paper :
DataGenCurves2 <- function(n, disp){
# n is the number of curves
# disp is the variance of the beta parameter
time <- seq(0,1,0.05) # Measurement times for inputs and output
id <- NULL # Id of the different curves
for (i in 1:n){
id <- c(id,rep(i,length(time)))
}
G1 <- 1*(runif(n)<0.5)  # Groupes of trajectories for the first input variable
G2 <- 1*(runif(n)<0.5)  # Groupes of trajectories for the second input variable
# Define the typical temporal behavior functions f.,. for the input variables :
f11 <- function(t){
return(0.5*t+0.1*sin(6*t))
}
f12 <- function(t){
return(0.3-0.7*(t-0.45)^2)
}
f21 <- function(t){
return(2*(t-0.5)^2 - t*0.3)
}
f22 <- function(t){
return(0.2 -0.3*t + 0.1*cos(8*t))
}
# Simulation of the Input Variables :
X1 <- NULL
X2 <- NULL
beta <- rnorm(n,1,disp) # Dilatation terms
for (i in 1:n){
X1 <- c(X1, beta[i]*((G1[i]==1)*f11(time)+(G1[i]==0)*f12(time)))
X2 <- c(X2, beta[i]*((G2[i]==1)*f21(time)+(G2[i]==0)*f22(time)))
}
X1 <- X1+ rnorm(length(X1), 0,0.02) # We add some noise
X2 <- X2+ rnorm(length(X2), 0,0.02) # We add some noise
X <- data.frame(X1,X2) # Data matrix
# Define the timepical temporal behavior functions g.,. for the Output :
g11 <- function(t){
return(t+ 0.3*sin(10*(t+1)))
}
g12<- function(t){
return(t+2*(t-0.7)^2)
}
g21 <- function(t){
return(1.5*exp(-(t-0.5)^2/0.5)- 0.1*(t+1)*cos(10*t))
}
g22 <- function(t){
return(log(13*abs(t+0.2))/(1+t))
}
# Output simulation :
Y <- NULL
for (i in 1:n){
Y <- c(Y, beta[i]*((G1[i]==1 & G2[i]==0)*(g11(time))+ (G1[i]==1 & G2[i]==1)*(g12(time )) + (G1[i]==0 & G2[i]==1)*(g21(time)) + (G1[i]==0 & G2[i]==0)*(g22(time))))
}
Y <- Y+ rnorm(length(Y), 0, 0.05) # We add some noise
# Here we plot the simulated data :
par(mfrow=c(1,3))
w <- which(id==1)
plot(time,X1[w], type="l", ylim=c(min(X1), max(X1)), col="grey",ylab="", xlab="time", main=TeX("$X^{(1)}$"))
for (i in 2:n){
w <- which(id==i)
lines(time,X1[w],col="grey")
}
lines(time,f11(time), col=1, lwd=2, lty=1)
lines(time,f12(time), col=1, lwd=2, lty=2)
legend("topleft", c(TeX("$f_{1,1}$"), TeX("f_{1,2}")), col=c(1,1), lty=c(1,2), lwd=c(2,2))
w <- which(id==1)
plot(time,X2[w], type="l", ylim=c(min(X2), max(X2)), col="grey", ylab="", xlab="time", main=TeX("$X^{(2)}$"))
for (i in 2:n){
w <- which(id==i)
lines(time,X2[w], col="grey")
}
lines(time,f21(time), col=1, lwd=2, lty=1)
lines(time,f22(time), col=1, lwd=2, lty=2)
legend("topleft", c(TeX("$f_{2,1}$"), TeX("f_{2,2}")), col=c(1,1), lty=c(1,2), lwd=c(2,2))
w <- which(id==1)
plot(time,Y[w], type="l", ylim=c(min(Y), max(Y)), col="grey", xlab="time", ylab="", main = TeX("$Y$"))
for (i in 1:n){
w <- which(id==i)
lines(time,Y[w], col="grey")
}
lines(time, g11(time), col=1, lwd=3, lty=1)
lines(time, g12(time), col=2, lwd=3, lty=2)
lines(time, g21(time), col=3, lwd=7, lty=3)
lines(time, g22(time), col=4, lwd=3, lty=4)
legend("topleft", c(TeX("$g_{1,1}$"), TeX("$g_{1,2}$"), TeX("$g_{2,1}$"), TeX("$g_{2,2}$")), col=c(1,2,3,4), lty=c(1,2,3,4), lwd=c(3,3,7,3))
par(mfrow=c(1,1))
return(list(X=X,Y=Y,time=rep(time,n), id=id))
}
# To simulate some data according to the first simulation scheme:
set.seed(123)
Data <- DataGenCurves2(100,0.3)
